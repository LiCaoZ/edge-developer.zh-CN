---
description: 使用基于标准的 Chakra JavaScript 引擎将脚本功能添加到你的 Windows 应用程序。
title: 托管 JavaScript 运行时
ms.date: 06/18/2020
ms.prod: microsoft-edge
ms.topic: article
ms.assetid: 30ec744e-57cc-4ef5-8fe1-d2c27b946548
caps.latest.revision: 14
author: MSEdgeTeam
ms.author: msedgedevrel
ms.openlocfilehash: 043f7ecd174515ce407d2fc0c2bbe796fa2750a5
ms.sourcegitcommit: 037a2d62333691104c9accb4862968f80a3465a2
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 06/18/2020
ms.locfileid: "10752246"
---
# <span data-ttu-id="52fcc-103">托管 JavaScript 运行时</span><span class="sxs-lookup"><span data-stu-id="52fcc-103">Hosting the JavaScript runtime</span></span>  

[!INCLUDE [deprecation-note](../includes/deprecation-note.md)]  

<span data-ttu-id="52fcc-104">JavaScript 运行时 (JsRT) Api 为 Windows 操作系统上运行的桌面版、Windows 应用商店和服务器端应用程序提供了一种方法，通过使用 Microsoft Edge 和 Internet Explorer 也使用的基于标准的 Chakra JavaScript 引擎，将脚本功能添加到应用程序。</span><span class="sxs-lookup"><span data-stu-id="52fcc-104">The JavaScript Runtime (JsRT) APIs provide a way for desktop, Windows Store, and server-side applications running on the Windows operating system to add scripting capabilities to the application by using the standards-based Chakra JavaScript engine that is also utilized by Microsoft Edge and Internet Explorer.</span></span> <span data-ttu-id="52fcc-105">这些 Api 可在 Windows 10 和安装了计算机上安装了 Internet Explorer 版本11.0 的任何 Windows 操作系统版本上使用。</span><span class="sxs-lookup"><span data-stu-id="52fcc-105">These APIs are available on Windows 10 and any version of the Windows operating system that has Internet Explorer version 11.0 installed on the machine.</span></span> <span data-ttu-id="52fcc-106">有关详细信息，请参阅 [ (JavaScript 运行时) 参考 ](../chakra-hosting/reference-javascript-runtime.md)。</span><span class="sxs-lookup"><span data-stu-id="52fcc-106">For more info, see [Reference (JavaScript Runtime)](../chakra-hosting/reference-javascript-runtime.md).</span></span> <span data-ttu-id="52fcc-107">有关在 Windows 应用商店应用中使用 JsRT 的信息，请参阅 [JsRT 和通用 Windows 平台](#Windows)。</span><span class="sxs-lookup"><span data-stu-id="52fcc-107">For info on using the JsRT in Windows Store apps, see [JsRT and the Universal Windows Platform](#Windows).</span></span>  

> [!NOTE]
> <span data-ttu-id="52fcc-108">本文档假定你对 JavaScript 语言的常规处理非常熟悉。</span><span class="sxs-lookup"><span data-stu-id="52fcc-108">This documentation assumes a general working familiarity with the JavaScript language.</span></span>  

## <span data-ttu-id="52fcc-109">概念</span><span class="sxs-lookup"><span data-stu-id="52fcc-109">Concepts</span></span>  

<span data-ttu-id="52fcc-110">了解如何使用 JsRT Api 托管 JavaScript 引擎取决于两个关键概念：运行时和执行上下文。</span><span class="sxs-lookup"><span data-stu-id="52fcc-110">Understanding how to host the JavaScript engine using the JsRT APIs depends on two key concepts: runtimes and execution contexts.</span></span>  

<span data-ttu-id="52fcc-111">*运行时*表示一个完整的 JavaScript 执行环境。</span><span class="sxs-lookup"><span data-stu-id="52fcc-111">A *runtime* represents a complete JavaScript execution environment.</span></span> <span data-ttu-id="52fcc-112">每个创建的运行时都有自己的独立垃圾回收堆，默认情况下，它自己的实时 (JIT) 编译器线程和垃圾回收器 (GC) 线程。</span><span class="sxs-lookup"><span data-stu-id="52fcc-112">Each runtime that is created has its own isolated garbage collected heap and, by default, its own just-in-time (JIT) compiler thread and garbage collector (GC) thread.</span></span> <span data-ttu-id="52fcc-113">*执行上下文*表示具有其自己的 javascript 全局对象与所有其他执行上下文不同的 javascript 环境。</span><span class="sxs-lookup"><span data-stu-id="52fcc-113">An *execution context* represents a JavaScript environment that has its own JavaScript global object distinct from all other execution contexts.</span></span> <span data-ttu-id="52fcc-114">一个运行时可能包含多个执行上下文，在这种情况下，所有执行上下文都共享与运行时关联的 JIT 编译器和 GC 线程。</span><span class="sxs-lookup"><span data-stu-id="52fcc-114">One runtime may contain multiple execution contexts, and in such cases, all the execution contexts share the JIT compiler and GC thread associated with the runtime.</span></span>  

<span data-ttu-id="52fcc-115">运行时表示单个执行线程。</span><span class="sxs-lookup"><span data-stu-id="52fcc-115">Runtimes represent a single thread of execution.</span></span> <span data-ttu-id="52fcc-116">一次只能有一个运行时在特定线程上处于活动状态，并且运行时一次只能在一个线程上处于活动状态。</span><span class="sxs-lookup"><span data-stu-id="52fcc-116">Only one runtime can be active on a particular thread at a time, and a runtime can only be active on one thread at a time.</span></span> <span data-ttu-id="52fcc-117">运行时是租赁线程，因此线程上当前未处于活动状态的运行时 (亦即未运行任何 JavaScript 代码或对来自主机) 的任何调用的响应均可用于尚未在其上有活动运行时的任何线程。</span><span class="sxs-lookup"><span data-stu-id="52fcc-117">Runtimes are rental threaded, so a runtime that is not currently active on a thread (i.e. isn't running any JavaScript code or responding to any calls from the host) can be used on any thread that doesn't already have an active runtime on it.</span></span>  

<span data-ttu-id="52fcc-118">执行上下文绑定到特定运行时并在该运行时中执行代码。</span><span class="sxs-lookup"><span data-stu-id="52fcc-118">Execution contexts are tied to a particular runtime and execute code within that runtime.</span></span> <span data-ttu-id="52fcc-119">与运行时不同，多个执行上下文可以同时在一个线程上处于活动状态。</span><span class="sxs-lookup"><span data-stu-id="52fcc-119">Unlike runtimes, multiple execution contexts can be active on a thread at the same time.</span></span> <span data-ttu-id="52fcc-120">因此，主机可以将调用转换为执行上下文，该执行上下文可以回调到主机，并且主机可以将调用转换为不同的执行上下文。</span><span class="sxs-lookup"><span data-stu-id="52fcc-120">So a host can make a call into an execution context, that execution context can call back to the host, and the host can make a call into a different execution context.</span></span>  

![多个执行上下文](../chakra-hosting/media/js-chakra-hosting.png "JS_Chakra_Hosting")  

<span data-ttu-id="52fcc-122">在实践中，除非主机需要在分离的环境中运行代码，否则可以使用单个执行上下文。</span><span class="sxs-lookup"><span data-stu-id="52fcc-122">In practice, unless a host needs to run code in separated environments, a single execution context can be used.</span></span> <span data-ttu-id="52fcc-123">同样，除非主机需要同时运行多个代码段，否则一次运行时就足够了。</span><span class="sxs-lookup"><span data-stu-id="52fcc-123">Similarly, unless a host needs to run multiple pieces of code concurrently, a single runtime is sufficient.</span></span>  

## <span data-ttu-id="52fcc-124">内存管理</span><span class="sxs-lookup"><span data-stu-id="52fcc-124">Memory management</span></span>  

<span data-ttu-id="52fcc-125">JavaScript 是一种垃圾回收的语言，因此在使用另一种语言的 JsRT Api 时，必须牢记几个注意事项。</span><span class="sxs-lookup"><span data-stu-id="52fcc-125">JavaScript is a garbage collected language, and thus there are several considerations that must be kept in mind when working with the JsRT APIs from another language.</span></span>  

<span data-ttu-id="52fcc-126">主要考虑是 JavaScript 垃圾回收器只能查看两个位置中的值的引用：其运行时堆和堆栈。</span><span class="sxs-lookup"><span data-stu-id="52fcc-126">The main consideration is that the JavaScript garbage collector can only see references to values in two places: its runtime's heap, and the stack.</span></span> <span data-ttu-id="52fcc-127">因此，对存储在其他 JavaScript 值内部或堆栈上的局部变量中的 JavaScript 值的引用始终会由垃圾回收器看到。</span><span class="sxs-lookup"><span data-stu-id="52fcc-127">Thus, a reference to a JavaScript value that is stored inside of another JavaScript value or in a local variable on the stack will always be seen by the garbage collector.</span></span> <span data-ttu-id="52fcc-128">但是，在其他位置（如由主机或系统托管的堆）中存储的引用将不会被垃圾回收器看到，并且可能会导致仍在由主机使用的值的提前收集。</span><span class="sxs-lookup"><span data-stu-id="52fcc-128">But references stored in other locations, such as heaps managed by the host or the system, will not be seen by the garbage collector and may result in premature collection of values that are still in use by the host.</span></span>  

> [!IMPORTANT]
> <span data-ttu-id="52fcc-129">某些语言编译器 (（如 Visual Studio c + + 编译器) ）可能会尽可能优化离开本地变量。</span><span class="sxs-lookup"><span data-stu-id="52fcc-129">Some language compilers (such as the Visual Studio C++ compiler) will optimize away local variables where possible.</span></span> <span data-ttu-id="52fcc-130">必须小心，以确保引用 JavaScript 值的局部变量在堆栈上是否应保持这些值处于活动状态。</span><span class="sxs-lookup"><span data-stu-id="52fcc-130">Care must be taken to ensure that local variables that reference JavaScript values are on the stack if they are expected to keep those values alive.</span></span>  

<span data-ttu-id="52fcc-131">如果对 JavaScript 值的引用将存储在对垃圾回收器不可见的位置，则主机必须使用 JsRT Api 手动添加和删除引用。</span><span class="sxs-lookup"><span data-stu-id="52fcc-131">If a reference to a JavaScript value will be stored in a location not visible to the garbage collector, the host must manually add and remove references using the JsRT APIs.</span></span>  

## <span data-ttu-id="52fcc-132">异常处理</span><span class="sxs-lookup"><span data-stu-id="52fcc-132">Exception handling</span></span>  

<span data-ttu-id="52fcc-133">当脚本执行期间出现 JavaScript 异常时，包含运行时将置于异常状态。</span><span class="sxs-lookup"><span data-stu-id="52fcc-133">When a JavaScript exception occurs during script execution, the containing runtime is put into an exception state.</span></span> <span data-ttu-id="52fcc-134">处于异常状态时，无法运行任何代码，并且所有 API 调用都将失败，并出现错误代码， `JsErrorInExceptionState` 直到主机使用 API 检索和清除异常 `JsGetAndClearException` 。</span><span class="sxs-lookup"><span data-stu-id="52fcc-134">While in an exception state, no code can run and all API calls will fail with the error code `JsErrorInExceptionState` until the host retrieves and clears the exception using the `JsGetAndClearException` API.</span></span> <span data-ttu-id="52fcc-135">如果主机从 JavaScript 回调返回，但未从异常状态中清除运行时，则当控件传递回 JavaScript 引擎时，将立即重新引发 JavaScript 异常。</span><span class="sxs-lookup"><span data-stu-id="52fcc-135">If the host returns from a JavaScript callback without clearing the runtime from an exception state, then the JavaScript exception will be re-thrown as soon as control passes back to the JavaScript engine.</span></span> <span data-ttu-id="52fcc-136">这还允许主机回调通过将运行时设置为异常状态，然后从主机回调中返回来 "引发" JavaScript 异常。</span><span class="sxs-lookup"><span data-stu-id="52fcc-136">This also enables host callbacks to "throw" a JavaScript exception by setting the runtime into an exception state and then returning from a host callback.</span></span>  

<span data-ttu-id="52fcc-137">不允许主机通过其自己的内部异常传播到主机回调-任何回调方法都必须在将控制权返回给运行时之前捕获所有主机异常。</span><span class="sxs-lookup"><span data-stu-id="52fcc-137">A host is not allowed to let its own internal exceptions to propagate across a host callback—any callback methods must catch all host exceptions before returning control to the runtime.</span></span>  

## <span data-ttu-id="52fcc-138">运行时资源使用情况</span><span class="sxs-lookup"><span data-stu-id="52fcc-138">Runtime resource usage</span></span>  

<span data-ttu-id="52fcc-139">JsRT Api 公开了多种方法来监视和修改运行时使用资源的方式。</span><span class="sxs-lookup"><span data-stu-id="52fcc-139">The JsRT APIs expose a number of way to monitor and modify the way runtimes use resources.</span></span> <span data-ttu-id="52fcc-140">它们通常细分为以下类别：</span><span class="sxs-lookup"><span data-stu-id="52fcc-140">They generally break down into the following categories:</span></span>  

*   <span data-ttu-id="52fcc-141">**线程使用**。</span><span class="sxs-lookup"><span data-stu-id="52fcc-141">**Thread Usage**.</span></span> <span data-ttu-id="52fcc-142">默认情况下，每个运行时将创建专用的 JIT 编译器线程和服务该运行时的专用 GC 线程。</span><span class="sxs-lookup"><span data-stu-id="52fcc-142">By default, each runtime will create a dedicated JIT compiler thread and a dedicated GC thread that service that runtime.</span></span> <span data-ttu-id="52fcc-143">如果使用标志创建运行时 `JsRuntimeAttributeDisableBackgroundWork` ，则 JIT 和 GC 工作将在运行时线程本身上执行，而不是针对每个线程在单独的后台线程上执行。</span><span class="sxs-lookup"><span data-stu-id="52fcc-143">If a runtime is created with the `JsRuntimeAttributeDisableBackgroundWork` flag, then the JIT and GC work will be performed on the runtime thread itself instead of separate background threads for each one of them.</span></span> <span data-ttu-id="52fcc-144">宿主还可以向调用提供线程服务回调 `JsCreateRuntime` ，从而使主机能够以其认为合适的任何方式计划 JIT 和 GC 工作。</span><span class="sxs-lookup"><span data-stu-id="52fcc-144">A host can also supply a thread service callback to the `JsCreateRuntime` call, which will allow the host to schedule JIT and GC work in any way it sees fit.</span></span>
*   <span data-ttu-id="52fcc-145">**内存使用**。</span><span class="sxs-lookup"><span data-stu-id="52fcc-145">**Memory Usage**.</span></span> <span data-ttu-id="52fcc-146">可通过多种方式监视和修改运行时的内存使用情况。</span><span class="sxs-lookup"><span data-stu-id="52fcc-146">There are several ways to monitor and modify the memory usage of a runtime.</span></span> <span data-ttu-id="52fcc-147">如果运行时将长时间运行，则主机可以 `JsRuntimeAttributeEnableIdleProcessing` 在创建运行时时指定标志，然后在 `JsIdle` 主机处于空闲状态时进行调用。</span><span class="sxs-lookup"><span data-stu-id="52fcc-147">If the runtime will be running for a long time, the host can specify the `JsRuntimeAttributeEnableIdleProcessing` flag when creating the runtime and then call `JsIdle` when the host is in an idle state.</span></span> <span data-ttu-id="52fcc-148">这使引擎能够推迟某些内存清理和簿记工作，直到空闲时间。</span><span class="sxs-lookup"><span data-stu-id="52fcc-148">This allows the engine to defer some memory cleanup and bookkeeping work until idle time.</span></span>  
    
    <span data-ttu-id="52fcc-149">主机可以通过调用监视垃圾回收 `JsSetRuntimeBeforeCollectCallback` 。</span><span class="sxs-lookup"><span data-stu-id="52fcc-149">The host can monitor garbage collections by calling `JsSetRuntimeBeforeCollectCallback`.</span></span> <span data-ttu-id="52fcc-150">它还可以通过调用来监视堆所进行的分配 `JsSetRuntimeMemoryAllocationCallback` 。</span><span class="sxs-lookup"><span data-stu-id="52fcc-150">It can also monitor allocations made by the heap by calling `JsSetRuntimeMemoryAllocationCallback`.</span></span> <span data-ttu-id="52fcc-151">请注意，仅当运行时堆需要更多要分配的空间时，此 API 才会在每个 JavaScript 分配上回调。</span><span class="sxs-lookup"><span data-stu-id="52fcc-151">Note that this API does not call back on every JavaScript allocation, just when the runtime's heap needs more space from which to allocate.</span></span> <span data-ttu-id="52fcc-152">允许内存分配回调拒绝请求，这将触发垃圾回收，如果没有内存可用，则运行时内存不足错误。</span><span class="sxs-lookup"><span data-stu-id="52fcc-152">The memory allocation callback is allowed to deny the request, which will trigger a garbage collection and, if no memory is available, an out of memory error in the runtime.</span></span>  
    
    <span data-ttu-id="52fcc-153">宿主还可以调用 `JsSetRuntimeMemoryLimit` 以设置对运行时可以使用的内存量的限制。</span><span class="sxs-lookup"><span data-stu-id="52fcc-153">The host can also call `JsSetRuntimeMemoryLimit` to set a limit for how much memory a runtime can use.</span></span> <span data-ttu-id="52fcc-154">当运行时达到限制时，它将触发垃圾回收，如果没有可用内存，则运行时将引发内存不足错误。</span><span class="sxs-lookup"><span data-stu-id="52fcc-154">When a runtime hits a limit, it will trigger a garbage collection and, if no memory is available, an out of memory error will be thrown by the runtime.</span></span>  
    
*   <span data-ttu-id="52fcc-155">**脚本中断和评估**。</span><span class="sxs-lookup"><span data-stu-id="52fcc-155">**Script Interruption and Evaluation**.</span></span> <span data-ttu-id="52fcc-156">主机可以调用 `JsDisableRuntimeExecution` 以终止运行时内的执行。</span><span class="sxs-lookup"><span data-stu-id="52fcc-156">The host can call `JsDisableRuntimeExecution` to terminate execution within a runtime.</span></span> <span data-ttu-id="52fcc-157">可随时通过任何线程进行此通话。</span><span class="sxs-lookup"><span data-stu-id="52fcc-157">This call can be made at any time and from any thread.</span></span> <span data-ttu-id="52fcc-158">由于脚本终止依赖于插入代码中插入的防护点，因此脚本可能不会完全终止，但随后会很快终止。</span><span class="sxs-lookup"><span data-stu-id="52fcc-158">Because script termination depends on reaching guard points inserted into the code, a script may not terminate at the exact moment, but will do so very shortly afterwards.</span></span> <span data-ttu-id="52fcc-159">默认情况下，终止防护点放置在生成的代码中，并且可能不涉及每种情况，如无限循环。</span><span class="sxs-lookup"><span data-stu-id="52fcc-159">By default, termination guard points are placed in the generated code conservatively and may not cover every situation, such as an infinite loop.</span></span> <span data-ttu-id="52fcc-160">使用标志创建运行时 `JsRuntimeAttributeAllowScriptInterrupt` 会导致运行时插入针对无限循环的其他检查，这通常会降低较小的性能开销。</span><span class="sxs-lookup"><span data-stu-id="52fcc-160">Creating the runtime with the `JsRuntimeAttributeAllowScriptInterrupt` flag causes the runtime to insert additional checks for infinite loops, often at the cost of a small performance overhead.</span></span>  
    
    <span data-ttu-id="52fcc-161">如果主机希望禁止 JIT 编译器生成本机代码，则可以指定该 `JsRuntimeAttributeDisableNativeCodeGeneration` 标志。</span><span class="sxs-lookup"><span data-stu-id="52fcc-161">If a host wishes to disallow generation of native code by the JIT compiler, it can specify the `JsRuntimeAttributeDisableNativeCodeGeneration` flag.</span></span> <span data-ttu-id="52fcc-162">宿主还可以禁止脚本通过指定标志来动态运行脚本 `JsRuntimeAttributeDisableEval` 。</span><span class="sxs-lookup"><span data-stu-id="52fcc-162">A host can also disallow scripts from dynamically running scripts itself by specifying the `JsRuntimeAttributeDisableEval` flag.</span></span>  
    
## <span data-ttu-id="52fcc-163">调试和分析</span><span class="sxs-lookup"><span data-stu-id="52fcc-163">Debugging and profiling</span></span>  

<span data-ttu-id="52fcc-164">JsRT Api 支持通过活动脚本技术进行调试和分析。</span><span class="sxs-lookup"><span data-stu-id="52fcc-164">JsRT APIs supports debugging and profiling via the Active Scripting technology.</span></span>  

<span data-ttu-id="52fcc-165">从 Windows 10 开始，Chakra JavaScript 引擎支持旧版 Internet Explorer (MSHTML) 引擎和新的 Microsoft Edge (EdgeHTML) 引擎，并且你可以在 JsRT (中找到 "目标 [Microsoft edge 与传统引擎](../chakra-hosting/targeting-edge-vs-legacy-engines-in-jsrt-apis.md) "，以了解详细信息) 。</span><span class="sxs-lookup"><span data-stu-id="52fcc-165">Starting in Windows 10, the Chakra JavaScript Engine supports the legacy Internet Explorer (MSHTML) engine and new Microsoft Edge (EdgeHTML) engine, and you can target either in JsRT (see [Targeting Microsoft Edge vs. Legacy Engines](../chakra-hosting/targeting-edge-vs-legacy-engines-in-jsrt-apis.md) for details).</span></span> <span data-ttu-id="52fcc-166">在 Visual Studio 中调试脚本的工作方式与旧版引擎和 Microsoft Edge 引擎的工作方式不同。</span><span class="sxs-lookup"><span data-stu-id="52fcc-166">Debugging a script in Visual Studio works differently between the legacy engine and Microsoft Edge engine.</span></span> <span data-ttu-id="52fcc-167">使用旧版引擎，主机需要提供 [IDebugApplication 接口](/scripting/winscript/reference/idebugapplication-interface) 指针，该接口指针可从 [IProcessDebugManager 接口](/scripting/winscript/reference/iprocessdebugmanager-interface) 实例中获取。</span><span class="sxs-lookup"><span data-stu-id="52fcc-167">With the legacy engine, the host needs to provide an [IDebugApplication Interface](/scripting/winscript/reference/idebugapplication-interface) pointer, which can be obtained from an [IProcessDebugManager Interface](/scripting/winscript/reference/iprocessdebugmanager-interface) instance.</span></span> <span data-ttu-id="52fcc-168">对于 Microsoft Edge 引擎， `IDebugApplication` 已弃用，并且 Chakra 引擎通过 Visual Studio 调试器启用本机和脚本调试功能，而无需 `IDebugApplication` 从用户实现。</span><span class="sxs-lookup"><span data-stu-id="52fcc-168">With the Microsoft Edge engine, `IDebugApplication` is deprecated, and the Chakra engine enables native and script debugging capabilities through the Visual Studio debugger without requiring an implementation of `IDebugApplication` from the user.</span></span>  

<span data-ttu-id="52fcc-169">若要使执行上下文中的脚本可调试，Chakra 引擎必须切换到使用效率较低的代码执行方法。</span><span class="sxs-lookup"><span data-stu-id="52fcc-169">To make scripts in an execution context debuggable, the Chakra engine has to switch to using less efficient code execution methods.</span></span> <span data-ttu-id="52fcc-170">因此，调试代码的运行速度通常比不可调试的代码更慢。</span><span class="sxs-lookup"><span data-stu-id="52fcc-170">As such, debuggable code typically runs slower than non-debuggable code.</span></span> <span data-ttu-id="52fcc-171">因此，使用旧版引擎，主机可以选择从开始在执行上下文中开始调试，方法是将 `IDebugApplication` 指针置于前面 `JsCreateContext` ，或者它可以等到需要调试，然后调用 `JsStartDebugging` 。</span><span class="sxs-lookup"><span data-stu-id="52fcc-171">As a result, with the legacy engine, a host can choose to either start debugging in an execution context from the beginning by providing the `IDebugApplication` pointer up front through `JsCreateContext`, or it can wait until debugging is needed and then call `JsStartDebugging`.</span></span> <span data-ttu-id="52fcc-172">使用 Microsoft Edge 引擎后，将 `JsCreateContext` 不再接受 `IDebugApplication` 参数，因此，脚本仅在调用后才可调试 `JsStartDebugging` 。</span><span class="sxs-lookup"><span data-stu-id="52fcc-172">With the Microsoft Edge engine, `JsCreateContext` no longer takes an `IDebugApplication` parameter, and as a result the script is debuggable only after `JsStartDebugging` is called.</span></span> <span data-ttu-id="52fcc-173">使用 Visual Studio 进行调试时，必须启用 "脚本" 调试器选项。</span><span class="sxs-lookup"><span data-stu-id="52fcc-173">When debugging using Visual Studio, the "Script" debugger option must be enabled.</span></span>  

<span data-ttu-id="52fcc-174">可通过两种方式之一来分析执行上下文中的 JavaScript 代码。</span><span class="sxs-lookup"><span data-stu-id="52fcc-174">The JavaScript code in an execution context can be profiled in one of two ways.</span></span> <span data-ttu-id="52fcc-175">命令行 Visual Studio Profiler ( # A0) 可以在 Windows 8.1 和更高版本中与/js 开关一起使用，以生成针对应用程序中运行的 JavaScript 代码的报表。</span><span class="sxs-lookup"><span data-stu-id="52fcc-175">The command line Visual Studio Profiler (vsperf.exe) can be used in Windows 8.1 and later versions with the /js switch to produce a report that targets the JavaScript code run in the application.</span></span> <span data-ttu-id="52fcc-176">或者，主机可以直接调用 `JsStartProfiling` 并 `JsStopProfiling` 提供用于执行分析的回调。</span><span class="sxs-lookup"><span data-stu-id="52fcc-176">Or the host can directly call `JsStartProfiling` and `JsStopProfiling` and provide a callback to do profiling itself.</span></span> <span data-ttu-id="52fcc-177">宿主还可以通过调用来检查垃圾回收的堆的状态 `JsEnumerateHeap` 。</span><span class="sxs-lookup"><span data-stu-id="52fcc-177">The host can also examine the state of the garbage collected heap by calling `JsEnumerateHeap`.</span></span> <span data-ttu-id="52fcc-178">JsRT 中的分析在旧版和 Microsoft Edge 引擎之间以相同的方式工作。</span><span class="sxs-lookup"><span data-stu-id="52fcc-178">Profiling in JsRT works in the same manner between the legacy and the Microsoft Edge engine.</span></span> <span data-ttu-id="52fcc-179">但是，JsRT 分析 api (`JsStartProfiling` 、 `JsStopProfiling` 、 `JsEnumerateHeap` 和 `JsIsEnumeratingHeap`) 不适用于通用 Windows 应用。</span><span class="sxs-lookup"><span data-stu-id="52fcc-179">However, JsRT profiling APIs (`JsStartProfiling`, `JsStopProfiling`, `JsEnumerateHeap`, and `JsIsEnumeratingHeap`) are not available for Universal Windows Apps.</span></span>  

<a name="Windows"></a>   

## <span data-ttu-id="52fcc-180">JsRT 和通用 Windows 平台</span><span class="sxs-lookup"><span data-stu-id="52fcc-180">JsRT and the Universal Windows Platform</span></span>  

<span data-ttu-id="52fcc-181">你可以使用 JsRT Api 将脚本功能添加到通用 Windows 应用。</span><span class="sxs-lookup"><span data-stu-id="52fcc-181">You can use JsRT APIs to add scripting capabilities to a Universal Windows app.</span></span> <span data-ttu-id="52fcc-182">使用 JsRT Api 的通用 Windows 应用将需要面向 Microsoft Edge JSRT Api，后者又面向 Edge Chakra 引擎。</span><span class="sxs-lookup"><span data-stu-id="52fcc-182">A Universal Windows app that uses the JsRT APIs will need to target the Microsoft Edge JSRT APIs, which in turn target the Edge Chakra engine.</span></span> <span data-ttu-id="52fcc-183">有关详细信息，请参阅确定 [Microsoft Edge 与传统引擎的目标](../chakra-hosting/targeting-edge-vs-legacy-engines-in-jsrt-apis.md)。</span><span class="sxs-lookup"><span data-stu-id="52fcc-183">For more information, see [Targeting Microsoft Edge vs. Legacy Engines](../chakra-hosting/targeting-edge-vs-legacy-engines-in-jsrt-apis.md).</span></span> <span data-ttu-id="52fcc-184">完整的 JsRT API 可用于通用 Windows 应用，但性能分析和堆枚举支持 (`JsStartProfiling` 、 `JsStopProfiling` 、 `JsEnumerateHeap` 和 `JsIsEnumeratingHeap` 不受支持) 。</span><span class="sxs-lookup"><span data-stu-id="52fcc-184">The complete JsRT API is available for Universal Windows apps, except for profiling and heap enumeration support (`JsStartProfiling`, `JsStopProfiling`, `JsEnumerateHeap`, and `JsIsEnumeratingHeap` are not supported).</span></span>  

<span data-ttu-id="52fcc-185">JsRT 还允许脚本在通过 Microsoft Edge JsRT API 公开 API 命名空间后，在任何 [通用 Windows 平台 (UWP) api](https://msdn.microsoft.com/library/windows/apps/br211377.aspx) 中进行访问 `JsProjectWinRTNamespace` 。</span><span class="sxs-lookup"><span data-stu-id="52fcc-185">JsRT also allows scripts to natively access any [Universal Windows Platform (UWP) APIs](https://msdn.microsoft.com/library/windows/apps/br211377.aspx) after exposing the API namespace through Microsoft Edge JsRT API `JsProjectWinRTNamespace`.</span></span> <span data-ttu-id="52fcc-186">除了在经典的 (Win32) Windows 应用程序中，即使通用的 Windows 应用程序不需要安装，但需要启用 COM 初始化的委派泵机制，才能 `JsSetProjectionEnqueueCallback` 启用事件和异步 api。</span><span class="sxs-lookup"><span data-stu-id="52fcc-186">While Universal Windows Applications require no setup in addition to projecting necessary namespaces, in a Classic (Win32) Windows Application, a COM-initialized delegated pumping mechanism needs to be enabled through `JsSetProjectionEnqueueCallback` to enable events and asynchronous APIs.</span></span> <span data-ttu-id="52fcc-187">以下 Win32 示例利用异步 UWP Api 创建 http 客户端以从 Uri 获取内容：</span><span class="sxs-lookup"><span data-stu-id="52fcc-187">The following Win32 sample utilizes asynchronous UWP APIs to create an http client to get content from a Uri:</span></span>  

```cpp
typedef struct _jsCall {
    JsProjectionCallback jsCallback;
    JsProjectionCallbackContext jsContext;
    HANDLE event;
} jsCall;

// Set up delegated pumping mechanism; not necessary in UWP applications.
jsCall outstandingCall = {};
CoInitializeEx(nullptr, COINIT_MULTITHREADED);
JsSetProjectionEnqueueCallback([](JsProjectionCallback jsCallback,
JsProjectionCallbackContext jsContext, void *callbackState) {
    jsCall* call = (jsCall*)callbackState;
    call->jsCallback = jsCallback;
    call->jsContext = jsContext;
    SetEvent(call->event);
    },
&outstandingCall);
HANDLE event = CreateEventEx(NULL, NULL, CREATE_EVENT_MANUAL_RESET, EVENT_ALL_ACCESS);
outstandingCall.event = event;

// Project necessary namespaces.
JsProjectWinRTNamespace(L"Windows.Foundation");
JsProjectWinRTNamespace(L"Windows.Web");

// Get content from an Uri.
JsRunScript(L"var uri = new Windows.Foundation.Uri(\"http://somedatasource.com\"); " \
    L"var httpClient = new Windows.Web.Http.HttpClient();" \
    L"httpClient.getStringAsync(uri).done(function (content) { " \
    L"    // do something with the string content " \
    L"}, onError); " \
    L"function onError(reason) { " \
    L"    // error handling " \
    L"}",
    currentSourceContext, L"", &result);

// Wait for async call to come in and then execute; not necessary in UWP applications.
WaitForSingleObjectEx(outstandingCall.event, 10000, FALSE) == WAIT_OBJECT_0;
outstandingCall.jsCallback(outstandingCall.jsContext);
```  

## <span data-ttu-id="52fcc-188">另请参阅</span><span class="sxs-lookup"><span data-stu-id="52fcc-188">See also</span></span>  

*   [<span data-ttu-id="52fcc-189">JavaScript 运行时示例应用</span><span class="sxs-lookup"><span data-stu-id="52fcc-189">JavaScript Runtime Sample App</span></span>](https://go.microsoft.com/fwlink/p/?LinkID=306674&clcid=0x409)   
*   [<span data-ttu-id="52fcc-190">应用 (JavaScript Runtime)</span><span class="sxs-lookup"><span data-stu-id="52fcc-190">Reference (JavaScript Runtime)</span></span>](../chakra-hosting/reference-javascript-runtime.md)   
*   [<span data-ttu-id="52fcc-191">JavaScript 运行时托管</span><span class="sxs-lookup"><span data-stu-id="52fcc-191">JavaScript Runtime Hosting</span></span>](../javascript-runtime-hosting.md)  
